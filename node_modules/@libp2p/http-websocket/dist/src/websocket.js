import { getHeaders } from '@libp2p/http-utils';
import { InvalidParametersError, TypedEventEmitter } from '@libp2p/interface';
import { isPromise, byteStream } from '@libp2p/utils';
import { Uint8ArrayList } from 'uint8arraylist';
import { CloseEvent, ErrorEvent } from './events.js';
import { encodeMessage, decodeMessage, CLOSE_MESSAGES } from './message.js';
import { performClientUpgrade, performServerUpgrade, readResponse, toBytes } from './utils.js';
const DATA_MESSAGES = ['BINARY', 'TEXT', 'CONTINUATION'];
const MAX_MESSAGE_SIZE = 10_485_760;
const DEFAULT_HOST = 'example.com';
export const HTTP_PROTOCOL = '/http/1.1';
class AbstractWebSocket extends TypedEventEmitter {
    binaryType = 'arraybuffer';
    bufferedAmount = 0;
    extensions = '';
    protocol = '';
    readyState;
    url;
    CONNECTING = 0;
    OPEN = 1;
    CLOSING = 2;
    CLOSED = 3;
    _onclose;
    _onerror;
    _onmessage;
    _onopen;
    sentClose;
    isClient;
    buffer;
    maxMessageSize;
    _url;
    closeController;
    constructor(url, init = {}) {
        super();
        this.readyState = this.CONNECTING;
        this.url = url.pathname;
        this.sentClose = false;
        this.isClient = init.isClient ?? true;
        this.buffer = new Uint8ArrayList();
        this.closeController = new AbortController();
        this.maxMessageSize = init.maxMessageSize ?? MAX_MESSAGE_SIZE;
    }
    send(data) {
        if (this.readyState !== this.OPEN) {
            throw new Error('WebSocket was not open');
        }
        const b = toBytes(data);
        if (isPromise(b)) {
            b.then(b => {
                this._send('BINARY', b);
            })
                .catch(err => {
                this._errored(err);
            });
        }
        else {
            this._send('BINARY', b);
        }
    }
    _send(type, data) {
        if (this.readyState !== this.OPEN) {
            return;
        }
        const message = encodeMessage(type, data, this.isClient);
        const byteLength = message.byteLength;
        this.bufferedAmount += byteLength;
        this._write(message, (err) => {
            this.bufferedAmount -= byteLength;
            if (err != null) {
                this._errored(err);
            }
        });
    }
    close(code, reason) {
        if (this.readyState !== this.OPEN) {
            throw new Error('WebSocket was not open');
        }
        this.readyState = this.CLOSING;
        this.sentClose = true;
        this._send('CONNECTION_CLOSE');
    }
    _errored(err) {
        this.readyState = this.CLOSED;
        this.dispatchEvent(new ErrorEvent(err));
    }
    set onclose(listener) {
        this._onclose = listener;
        this.addEventListener('close', listener);
    }
    get onclose() {
        return this._onclose ?? null;
    }
    set onerror(listener) {
        this._onerror = listener;
        this.addEventListener('error', listener);
    }
    get onerror() {
        return this._onerror ?? null;
    }
    set onmessage(listener) {
        this._onmessage = listener;
        this.addEventListener('message', listener);
    }
    get onmessage() {
        return this._onmessage ?? null;
    }
    set onopen(listener) {
        this._onopen = listener;
        this.addEventListener('open', listener);
    }
    get onopen() {
        return this._onopen ?? null;
    }
    _push(buf) {
        this.buffer.append(buf);
        if (this.buffer.byteLength > this.maxMessageSize) {
            this.close(CLOSE_MESSAGES.MESSAGE_TOO_BIG, 'Max message size exceeded');
            return;
        }
        while (true) {
            const message = decodeMessage(this.buffer);
            if (message == null) {
                break;
            }
            if (DATA_MESSAGES.includes(message.type) && message.data != null) {
                let data;
                if (this.binaryType === 'blob') {
                    data = new Blob([message.data]);
                }
                else {
                    if (message.data.byteOffset === 0 && message.data.byteLength === message.data.buffer.byteLength) {
                        // Uint8Array aligns with underlying ArrayBuffer
                        data = message.data.buffer;
                    }
                    else {
                        // Uint8Array is a view on a larger ArrayBuffer, copy data before
                        // emitting. This is inefficient and slow but that's WebSockets
                        data = new ArrayBuffer(message.data.byteLength);
                        new Uint8Array(data, 0, data.byteLength).set(message.data);
                    }
                }
                this.dispatchEvent(new MessageEvent('message', {
                    data,
                    origin: this._url?.hostname
                }));
            }
            // respond to pings
            if (message.type === 'PING') {
                this._send('PONG', message.data);
            }
            // close handshake
            if (message.type === 'CONNECTION_CLOSE') {
                if (!this.sentClose) {
                    this.close();
                }
                this.closeController.abort();
                this._close(undefined, () => {
                    this.readyState = this.CLOSED;
                    this.dispatchEvent(new CloseEvent('close'));
                });
            }
        }
    }
    /**
     * To be invoked when the underlying transport is closed by the remote end
     */
    _remoteClosed(err) {
        this.readyState = this.CLOSING;
        this._close(err, () => {
            this.readyState = this.CLOSED;
            this.dispatchEvent(new CloseEvent('close'));
        });
    }
}
export class ServerWebSocket extends AbstractWebSocket {
    duplex;
    constructor(request, duplex, init = {}) {
        super(new URL(`http://${request.headers.host ?? DEFAULT_HOST}${request.url}`), {
            ...init,
            isClient: false
        });
        this.duplex = duplex;
        this.duplex.on('data', (buf) => {
            this._push(buf);
        });
        this.duplex.on('close', () => {
            this.close();
        });
        this.duplex.on('error', (err) => {
            this.close(CLOSE_MESSAGES.ABNORMAL_CLOSURE, err.message);
        });
        Promise.resolve().then(async () => {
            for await (const buf of performServerUpgrade(request.headers)) {
                this.duplex.write(buf);
            }
            this.readyState = this.OPEN;
            this.dispatchEvent(new Event('open'));
        })
            .catch(err => {
            this.duplex.destroy(err);
        });
    }
    _write(buf, cb) {
        this.duplex.write(buf.subarray(), cb);
    }
    _close(err, cb) {
        this.readyState = this.CLOSED;
        this.duplex.destroy(err);
        cb();
    }
}
export class StreamWebSocket extends AbstractWebSocket {
    bytes;
    constructor(info, stream, init) {
        super(new URL(`http://${info.headers.get('host') ?? DEFAULT_HOST}${info.url}`), {
            ...init,
            isClient: false
        });
        this.bytes = byteStream(stream);
        Promise.resolve()
            .then(async () => {
            for await (const buf of performServerUpgrade(info.headers)) {
                await this.bytes.write(buf);
            }
            this.readyState = this.OPEN;
            this.dispatchEvent(new Event('open'));
            while (true) {
                const buf = await this.bytes.read();
                if (buf == null) {
                    this._remoteClosed();
                    break;
                }
                this._push(buf);
            }
        })
            .catch(err => {
            this._errored(err);
        });
    }
    _write(buf, cb) {
        this.bytes?.write(buf)
            .then(() => {
            cb();
        }, err => {
            cb(err);
        });
    }
    _close(err, cb) {
        const stream = this.bytes?.unwrap();
        if (err != null) {
            stream?.abort(err);
            cb();
        }
        else {
            stream?.close()
                .then(() => {
                cb();
            }, err => {
                stream.abort(err);
                cb();
            });
        }
    }
}
export class RequestWebSocket extends AbstractWebSocket {
    writer;
    writable;
    constructor(request, writable, init = {}) {
        super(new URL(request.url), {
            ...init,
            isClient: false
        });
        if (request.body == null) {
            throw new InvalidParametersError('Request body cannot be null');
        }
        this.readyState = this.OPEN;
        this.writable = writable;
        this.writer = writable.getWriter();
        const reader = request.body.getReader();
        Promise.resolve()
            .then(async () => {
            this.dispatchEvent(new Event('open'));
            while (true) {
                const { value, done } = await reader.read();
                if (value != null) {
                    this._push(value);
                }
                if (done) {
                    this._remoteClosed();
                    break;
                }
            }
        })
            .catch(err => {
            this._errored(err);
        });
    }
    _write(buf, cb) {
        this.writer?.write(buf)
            .then(() => {
            cb();
        }, err => {
            cb(err);
        });
    }
    _close(err, cb) {
        if (err != null) {
            this.writable.abort(err)
                .then(() => {
                cb();
            }, () => {
                cb();
            });
        }
        else {
            this.writable.close()
                .then(() => {
                cb();
            }, () => {
                cb();
            });
        }
    }
}
export class WebSocket extends AbstractWebSocket {
    stream;
    handshakeTimeout;
    drainTimeout;
    constructor(mas, url, connectionManager, init) {
        super(url, {
            ...init,
            isClient: true
        });
        this.handshakeTimeout = init.handshakeTimeout ?? 10_000;
        this.drainTimeout = init.drainTimeout ?? 10_000;
        Promise.resolve()
            .then(async () => {
            const signal = AbortSignal.timeout(this.handshakeTimeout);
            this.stream = await connectionManager.openStream(mas, HTTP_PROTOCOL, {
                ...init,
                signal
            });
            for await (const buf of performClientUpgrade(url, init.protocols, getHeaders(init))) {
                if (!this.stream.send(buf)) {
                    await this.stream.onDrain({
                        signal
                    });
                }
            }
            const res = await readResponse(this.stream, {
                signal
            });
            if (res.status !== 101) {
                throw new Error('Invalid WebSocket handshake - response status ' + res.status);
            }
            await init.onHandshakeResponse?.(res, {
                signal
            });
            // if a protocol was selected by the server, expose it
            this.protocol = res.headers.get('Sec-WebSocket-Protocol') ?? '';
            this.readyState = this.OPEN;
            this.dispatchEvent(new Event('open'));
            for await (const buf of this.stream) {
                this._push(buf);
            }
        })
            .catch(err => {
            this._errored(err);
        });
    }
    _write(buf, cb) {
        if (this.stream == null) {
            cb(new Error('WebSocket was not open'));
            return;
        }
        if (!this.stream.send(buf)) {
            this.stream.onDrain({
                signal: AbortSignal.timeout(this.drainTimeout)
            }).then(() => {
                cb();
            }, (err) => {
                cb(err);
            });
        }
        else {
            cb();
        }
    }
    _close(err, cb) {
        if (this.stream == null) {
            cb();
            return;
        }
        if (err != null) {
            this.stream.abort(err);
            cb();
            return;
        }
        this.stream.close()
            .catch((err) => {
            this.stream?.abort(err);
        })
            .finally(() => {
            cb();
        });
    }
}
//# sourceMappingURL=websocket.js.map