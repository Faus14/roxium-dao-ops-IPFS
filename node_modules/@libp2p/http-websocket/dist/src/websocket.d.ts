import { TypedEventEmitter } from '@libp2p/interface';
import { Uint8ArrayList } from 'uint8arraylist';
import type { CloseListener, ErrorListener, MessageListener, OpenListener, WebSocketEvents, WebSocketInit } from './index.js';
import type { MESSAGE_TYPE } from './message.js';
import type { HeaderInfo } from '@libp2p/http-utils';
import type { AbortOptions, Stream } from '@libp2p/interface';
import type { ConnectionManager } from '@libp2p/interface-internal';
import type { Multiaddr } from '@multiformats/multiaddr';
import type { IncomingMessage } from 'node:http';
import type { Duplex } from 'node:stream';
export declare const HTTP_PROTOCOL = "/http/1.1";
interface AbstractWebSocketInit extends AbortOptions {
    protocols?: string[];
    isClient?: boolean;
    maxMessageSize?: number;
    headers?: Headers;
}
declare abstract class AbstractWebSocket extends TypedEventEmitter<WebSocketEvents> {
    readonly binaryType: 'arraybuffer' | 'blob';
    bufferedAmount: number;
    extensions: string;
    protocol: string;
    readyState: number;
    url: string;
    CONNECTING: 0;
    OPEN: 1;
    CLOSING: 2;
    CLOSED: 3;
    private _onclose?;
    private _onerror?;
    private _onmessage?;
    private _onopen?;
    private sentClose;
    private readonly isClient;
    private readonly buffer;
    private readonly maxMessageSize;
    protected readonly _url?: URL;
    protected readonly closeController: AbortController;
    constructor(url: URL, init?: AbstractWebSocketInit);
    send(data: string | Blob | Uint8Array | ArrayBuffer | DataView): void;
    _send(type: MESSAGE_TYPE, data?: Uint8Array): void;
    close(code?: number, reason?: string): void;
    _errored(err: Error): void;
    set onclose(listener: CloseListener);
    get onclose(): CloseListener | null;
    set onerror(listener: ErrorListener);
    get onerror(): ErrorListener | null;
    set onmessage(listener: MessageListener);
    get onmessage(): MessageListener | null;
    set onopen(listener: OpenListener);
    get onopen(): OpenListener | null;
    protected _push(buf: Uint8Array | Uint8ArrayList): void;
    /**
     * To be invoked when the underlying transport is closed by the remote end
     */
    protected _remoteClosed(err?: Error): void;
    /**
     * Invoked when data is to be sent over the socket, the passed callback should
     * be called when the data has been written
     */
    protected abstract _write(buf: Uint8ArrayList, cb: (err?: Error | null) => void): void;
    /**
     * The implementation of this method should close the underlying transport. If
     * an error is passed, the transport should be closed immediately.
     *
     * The passed callback should be invoked when the transport has closed
     */
    protected abstract _close(err: Error | undefined, cb: () => void): void;
}
export declare class ServerWebSocket extends AbstractWebSocket {
    private readonly duplex;
    constructor(request: IncomingMessage, duplex: Duplex, init?: AbstractWebSocketInit);
    _write(buf: Uint8ArrayList, cb: (err?: Error | null) => void): void;
    _close(err: Error, cb: () => void): void;
}
export declare class StreamWebSocket extends AbstractWebSocket {
    private readonly bytes;
    constructor(info: HeaderInfo, stream: Stream, init?: AbstractWebSocketInit);
    _write(buf: Uint8ArrayList, cb: (err?: Error | null) => void): void;
    _close(err: Error, cb: () => void): void;
}
export declare class RequestWebSocket extends AbstractWebSocket {
    private readonly writer;
    private readonly writable;
    constructor(request: Request, writable: WritableStream, init?: AbstractWebSocketInit);
    _write(buf: Uint8ArrayList, cb: (err?: Error | null) => void): void;
    _close(err: Error, cb: () => void): void;
}
export declare class WebSocket extends AbstractWebSocket {
    private stream?;
    private handshakeTimeout;
    private drainTimeout;
    constructor(mas: Multiaddr[], url: URL, connectionManager: ConnectionManager, init: WebSocketInit);
    _write(buf: Uint8ArrayList, cb: (err?: Error | null) => void): void;
    _close(err: Error | undefined, cb: () => void): void;
}
export {};
//# sourceMappingURL=websocket.d.ts.map