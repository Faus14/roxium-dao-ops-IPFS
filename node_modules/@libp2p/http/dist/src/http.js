import { Agent as NodeAgent } from 'node:http';
import { Libp2pSocket, toResource } from '@libp2p/http-utils';
import { isPeerId } from '@libp2p/interface';
import { Agent as UndiciAgent } from 'undici';
import { HTTP_PROTOCOL } from './constants.js';
import { HTTP as HTTPBrowser } from './http.browser.js';
function createConnection(connectionManager, peer, options) {
    return new Libp2pSocket(Promise.resolve()
        .then(async () => {
        const connection = await connectionManager.openConnection(peer, options);
        const stream = await connection.newStream(HTTP_PROTOCOL, options);
        return { stream, connection };
    }));
}
export class Libp2pDispatcher extends UndiciAgent {
    constructor(components, init) {
        super({
            ...init,
            connect: (options, cb) => {
                const socket = createConnection(components.connectionManager, init.peer, {
                    // @ts-expect-error types are wonky
                    signal: options.timeout != null ? AbortSignal.timeout(options.timeout) : undefined
                });
                const onConnect = () => {
                    socket.removeListener('error', onError);
                    socket.removeListener('connect', onConnect);
                    cb(null, socket);
                };
                const onError = (err) => {
                    socket.removeListener('error', onError);
                    socket.removeListener('connect', onConnect);
                    cb(err, null);
                };
                socket.addListener('connect', onConnect);
                socket.addListener('error', onError);
            }
        });
    }
}
class Libp2pAgent extends NodeAgent {
    keepAliveMsecs = 100;
    components;
    peer;
    constructor(components, init) {
        super(init);
        this.components = components;
        this.peer = init.peer;
    }
    createConnection(options, cb) {
        const socket = createConnection(this.components.connectionManager, this.peer, options);
        const onConnect = () => {
            socket.removeListener('error', onError);
            socket.removeListener('connect', onConnect);
            cb(null, socket);
        };
        const onError = (err) => {
            socket.removeListener('error', onError);
            socket.removeListener('connect', onConnect);
            cb(err, socket);
        };
        socket.addListener('connect', onConnect);
        socket.addListener('error', onError);
        return socket;
    }
}
export class HTTP extends HTTPBrowser {
    agent(peer, options) {
        if (!isPeerId(peer) && toResource(peer) instanceof URL) {
            return new NodeAgent(options);
        }
        return new Libp2pAgent(this.components, {
            ...options,
            peer
        });
    }
    dispatcher(peer, options) {
        if (!isPeerId(peer) && toResource(peer) instanceof URL) {
            return new UndiciAgent(options);
        }
        return new Libp2pDispatcher(this.components, {
            ...options,
            peer
        });
    }
}
//# sourceMappingURL=http.js.map