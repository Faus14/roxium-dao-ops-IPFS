import { createServerChallenge, serverResponds } from '@libp2p/http-peer-id-auth';
import { normalizeMethod } from '@libp2p/http-utils';
import { WEBSOCKET_HANDLER } from '../constants.js';
import { initializeRoute } from './utils.js';
import { webSocketRoute } from './websocket.js';
export const DEFAULT_AUTH_TOKEN_TTL = 60 * 60 * 1000; // 1 hour
export class PeerIdAuth {
    components;
    log;
    tokenTTL;
    verifyHostname;
    requireAuth;
    constructor(components, init) {
        this.components = components;
        this.log = components.logger.forComponent('libp2p:http:server-peer-id-auth');
        this.tokenTTL = init.tokenTTL ?? DEFAULT_AUTH_TOKEN_TTL;
        this.requireAuth = init.requireAuth ?? true;
        this.verifyHostname = init.verifyHostname ?? (() => true);
    }
    async authenticateRequest(hostname, method, authHeader) {
        if (!(await this.verifyHostname(hostname))) {
            this.log.error('hostname verification failed');
            return { status: 400 };
        }
        if (authHeader == null || authHeader === '') {
            // OPTIONS is used by preflight request - cannot enforce auth on it as
            // browsers throw "failed to fetch" errors
            if (method === 'OPTIONS' || this.requireAuth === false) {
                return { status: 200 };
            }
            return this.returnChallenge(hostname);
        }
        try {
            const result = await serverResponds(authHeader, hostname, this.components.privateKey, this.tokenTTL);
            const headers = new Headers();
            let status = 200;
            if (result.info != null) {
                headers.set('authentication-info', result.info);
                headers.set('access-control-expose-headers', 'authentication-info');
            }
            if (result.authenticate != null) {
                status = 401;
                headers.set('www-authenticate', result.authenticate);
                headers.set('access-control-expose-headers', 'www-authenticate');
            }
            return {
                status,
                headers,
                peer: result.peerId
            };
        }
        catch (err) {
            this.log.error('failed to respond to client challenge - %e', err);
            if (err.name === 'InvalidMessageError') {
                return { status: 400 };
            }
            if (err.name === 'NotAuthenticatedError') {
                return this.returnChallenge(hostname);
            }
            throw err;
        }
    }
    async returnChallenge(hostname) {
        return {
            status: 401,
            headers: new Headers({
                'www-authenticate': await createServerChallenge(hostname, this.components.privateKey),
                'access-control-expose-headers': 'www-authenticate'
            })
        };
    }
}
function isOptionalAuth(obj) {
    return obj.requireAuth === false;
}
async function authenticate(req, authResult, handlerMethods, next) {
    const authIsOptional = isOptionalAuth(next);
    if (!authIsOptional && (authResult.peer == null || authResult.status !== 200)) {
        return new Response(undefined, {
            status: authResult.status,
            headers: authResult.headers
        });
    }
    if (!handlerMethods.includes(req.method)) {
        // handle auth requests
        let res;
        if (req.method === 'OPTIONS') {
            // support OPTIONS if the handler doesn't
            res = new Response(undefined, {
                status: 204,
                headers: authResult.headers
            });
        }
        else {
            // unsupported method
            res = new Response(undefined, {
                status: 405
            });
        }
        // add auth headers to response
        if (authResult.headers !== undefined) {
            for (const [key, value] of authResult.headers) {
                res.headers.set(key, value);
            }
        }
        return res;
    }
    // @ts-expect-error cannot derive handler type
    return next.handler(req, authResult.peer);
}
export function authenticatedRoute(handler) {
    const handlerMethods = normalizeMethod(handler.method);
    return {
        path: handler.path,
        method: ['OPTIONS', ...handlerMethods],
        cors: handler.cors,
        init: (components) => {
            const auth = new PeerIdAuth(components, handler);
            const next = initializeRoute(handler, components);
            return async (req) => {
                const authResult = await auth.authenticateRequest(readHostname(req), req.method, req.headers.get('Authorization'));
                return authenticate(req, authResult, handlerMethods, next);
            };
        }
    };
}
export function authenticatedWebSocketRoute(handler) {
    const handlerMethods = normalizeMethod(handler.method);
    const output = {
        path: handler.path,
        method: ['OPTIONS', ...handlerMethods],
        cors: handler.cors,
        init: (components) => {
            const auth = new PeerIdAuth(components, handler);
            const next = initializeRoute(handler, components);
            // allow invoking the handler with a pre-upgraded socket
            output[WEBSOCKET_HANDLER] = (ws) => {
                // need to read the authorization header from the websocket protocol
                // TODO: we should have a way of doing this before the websocket upgrade
                // has been negotiated
                auth.authenticateRequest(readHostname(ws), '', readProtocol(ws))
                    .then(authResult => {
                    next.handler(ws, authResult.peer);
                })
                    .catch(() => {
                    ws.close();
                });
            };
            return async (req) => {
                const authResult = await auth.authenticateRequest(readHostname(req), req.method, readAuthorization(req) ?? readSecWebSocketProtocol(req));
                return authenticate(req, authResult, handlerMethods, {
                    ...next,
                    handler: async (req, peerId) => {
                        const wsRoute = initializeRoute(webSocketRoute({
                            ...next,
                            handler: (ws) => {
                                next.handler(ws, peerId);
                            },
                            fallback: next.fallback == null
                                ? undefined
                                : async (req) => {
                                    return authenticate(req, authResult, handlerMethods, {
                                        ...next,
                                        handler: async (res, peerId) => {
                                            if (next.fallback == null) {
                                                // should not get here because we have already
                                                // null-guarded on `handler.fallback`
                                                return new Response(undefined, {
                                                    status: 500
                                                });
                                            }
                                            return next.fallback(res, peerId);
                                        }
                                    });
                                }
                        }), components);
                        return wsRoute.handler(req);
                    }
                });
            };
        }
    };
    return output;
}
function readHostname(req) {
    const url = new URL(req.url);
    let hostname = url.hostname;
    if (url.port === '' || url.port === undefined) {
        return hostname;
    }
    if (url.protocol === 'http:' && url.port !== '80') {
        hostname += ':' + url.port;
    }
    if (url.protocol === 'https:' && url.port !== '443') {
        hostname += ':' + url.port;
    }
    if (hostname === '') {
        throw new Error('No hostname');
    }
    return hostname;
}
function readAuthorization(req) {
    const authorization = req.headers.get('Authorization');
    if (authorization == null) {
        return;
    }
    return authorization;
}
export const SEC_WEBSOCKET_PROTOCOL_PREFIX = 'authorization=';
function readSecWebSocketProtocol(req) {
    const protocol = req.headers.get('Sec-WebSocket-Protocol');
    if (protocol == null) {
        return;
    }
    const protos = protocol.split(',');
    const authorization = protos
        .filter(p => p.startsWith(SEC_WEBSOCKET_PROTOCOL_PREFIX))
        .pop();
    // remove authorization field from protocol if present
    if (authorization != null) {
        req.headers.set('Sec-WebSocket-Protocol', protos
            .filter(p => !p.startsWith(SEC_WEBSOCKET_PROTOCOL_PREFIX))
            .join(','));
    }
    if (authorization == null) {
        return;
    }
    return atob(authorization.substring(SEC_WEBSOCKET_PROTOCOL_PREFIX.length));
}
function readProtocol(ws) {
    const protocol = ws.protocol;
    if (protocol == null) {
        return;
    }
    const protos = protocol.split(',');
    const authorization = protos
        .filter(p => p.startsWith(SEC_WEBSOCKET_PROTOCOL_PREFIX))
        .pop();
    // remove authorization field from protocol if present
    if (authorization != null) {
        ws.protocol = protos
            .filter(p => !p.startsWith(SEC_WEBSOCKET_PROTOCOL_PREFIX))
            .join(',');
    }
    if (authorization == null) {
        return;
    }
    return atob(authorization.substring(SEC_WEBSOCKET_PROTOCOL_PREFIX.length));
}
//# sourceMappingURL=peer-id-auth.js.map