import type { HTTPRoute } from '../index.js';
import type { ComponentLogger, Logger, PeerId, PrivateKey } from '@libp2p/interface';
export declare const DEFAULT_AUTH_TOKEN_TTL: number;
interface PeerIdAuthComponents {
    privateKey: PrivateKey;
    logger: ComponentLogger;
}
interface AuthenticationResult {
    status: number;
    headers?: Headers;
    peer?: PeerId | undefined;
}
interface PeerIdAuthInit {
    tokenTTL?: number;
    verifyHostname?(hostname: string): boolean | Promise<boolean>;
    /**
     * If true, and the client has not initiated the HTTP PeerId Auth handshake,
     * have the server do it.
     *
     * @default true
     */
    requireAuth?: boolean;
}
export declare class PeerIdAuth {
    private readonly components;
    readonly log: Logger;
    private readonly tokenTTL;
    private readonly verifyHostname;
    private readonly requireAuth;
    constructor(components: PeerIdAuthComponents, init: PeerIdAuthInit);
    authenticateRequest(hostname: string, method: string, authHeader?: string | null): Promise<AuthenticationResult>;
    private returnChallenge;
}
export interface AuthenticationOptions {
    /**
     * How long in ms an auth token for a server will be valid for, defaults to
     * one hour
     *
     * @default 360_000
     */
    tokenTTL?: number;
    /**
     * An optional function that can be used to verify that the hostname of the
     * incoming request is valid and supported
     */
    verifyHostname?(hostname: string): boolean | Promise<boolean>;
    /**
     * If true the request will be rejected if the client does not supply an
     * `Authorization` header, pass `false` here to attempt to verify the client
     * but allow the request to proceed if it fails
     *
     * @default true
     */
    requireAuth?: boolean;
}
export interface OptionalAuthenticationOptions extends AuthenticationOptions {
    /**
     * If true the request will be rejected if the client does not supply an
     * `Authorization` header, pass `false` here to attempt to verify the client
     * but allow the request to proceed if it fails
     *
     * @default true
     */
    requireAuth: false;
}
export interface AuthenticatedWebSocketOptions extends AuthenticationOptions {
    /**
     * If the request was not a WebSocket request, invoke this method
     */
    fallback?: AuthenticatedHTTPRequestHandler;
    /**
     * The maximum message size to be sent or received over the socket in bytes
     *
     * @default 10_485_760
     */
    maxMessageSize?: number;
}
export interface OptionallyAuthenticatedWebSocketOptions extends OptionalAuthenticationOptions {
    /**
     * If the request was not a WebSocket request, invoke this method
     */
    fallback?: OptionallyAuthenticatedHTTPRequestHandler;
    /**
     * The maximum message size to be sent or received over the socket in bytes
     *
     * @default 10_485_760
     */
    maxMessageSize?: number;
}
/**
 * An HTTP handler that accepts the PeerId of the client as an argument
 */
export interface AuthenticatedHTTPRequestHandler {
    (req: Request, peerId: PeerId): Promise<Response>;
}
/**
 * An HTTP handler that accepts the PeerId of the client as an argument, if they
 * provided a valid Authorization header
 */
export interface OptionallyAuthenticatedHTTPRequestHandler {
    (req: Request, peerId?: PeerId): Promise<Response>;
}
/**
 * An WebSocket handler that accepts the PeerId of the client as an argument
 */
export interface AuthenticatedWebSocketHandler {
    (socket: WebSocket, peerId: PeerId): void;
}
/**
 * An WebSocket handler that accepts the PeerId of the client as an argument, if
 * they provided a valid Authorization header
 */
export interface OptionallyAuthenticatedWebSocketHandler {
    (socket: WebSocket, peerId?: PeerId): void;
}
type OptionallyAuthenticatedEndpoint = HTTPRoute<OptionallyAuthenticatedHTTPRequestHandler> & OptionalAuthenticationOptions;
type AuthenticatedEndpoint = HTTPRoute<AuthenticatedHTTPRequestHandler> & AuthenticationOptions;
/**
 * Attempt to authenticate the client before request processing to discover
 * their PeerID.
 *
 * If the `requireAuth` option is false, no authentication will be attempted
 * unless the client initiates it.
 *
 * If it is `true` or `undefined`, the server will initiate the authentication
 * handshake if the client has not done so.
 *
 * @see https://github.com/libp2p/specs/blob/master/http/peer-id-auth.md
 */
export declare function authenticatedRoute(handler: OptionallyAuthenticatedEndpoint): HTTPRoute;
export declare function authenticatedRoute(handler: AuthenticatedEndpoint): HTTPRoute;
type OptionallyAuthenticatedWebSocketEndpoint = HTTPRoute<OptionallyAuthenticatedWebSocketHandler> & OptionallyAuthenticatedWebSocketOptions;
type AuthenticatedWebSocketEndpoint = HTTPRoute<AuthenticatedWebSocketHandler> & AuthenticatedWebSocketOptions;
/**
 * Attempt to authenticate the client before request processing to discover
 * their PeerID.
 *
 * The authorization token should be passed as a protocol prefixed with
 * `authorization=`.
 *
 * To allow use of actual protocol field, multiple values should be
 * comma-delimited, e.g. `authorization=foo,actual,useful,protocols`
 *
 * @see https://github.com/libp2p/specs/blob/master/http/peer-id-auth.md
 */
export declare function authenticatedWebSocketRoute(handler: OptionallyAuthenticatedWebSocketEndpoint): HTTPRoute;
export declare function authenticatedWebSocketRoute(handler: AuthenticatedWebSocketEndpoint): HTTPRoute;
export declare const SEC_WEBSOCKET_PROTOCOL_PREFIX = "authorization=";
export {};
//# sourceMappingURL=peer-id-auth.d.ts.map