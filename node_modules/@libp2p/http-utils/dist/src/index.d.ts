/**
 * @packageDocumentation
 *
 * Contains shared code and utilities used by `@libp2p/http-*` modules.
 */
import { Uint8ArrayList } from 'uint8arraylist';
import type { AbortOptions, PeerId, Stream } from '@libp2p/interface';
import type { Multiaddr } from '@multiformats/multiaddr';
/**
 * A subset of options passed to middleware
 */
export interface MiddlewareOptions extends AbortOptions {
    method: string;
    headers: Headers;
    middleware: Middleware[];
    credentials?: RequestCredentials;
    keepalive?: boolean;
    redirect?: RequestRedirect;
    integrity?: string;
    mode?: RequestMode;
    referrer?: string;
    referrerPolicy?: ReferrerPolicy;
}
/**
 * Middleware that allows augmenting the client request/response with additional
 * fields or headers.
 */
export interface Middleware {
    /**
     * Called before a request is made
     */
    prepareRequest?(resource: URL | Multiaddr[], opts: MiddlewareOptions): void | Promise<void>;
    /**
     * Called after a request is made but before the body has been read - the
     * processor may do any necessary housekeeping based on the server response
     */
    processResponse?(resource: URL | Multiaddr[], opts: MiddlewareOptions, response: Response): void | Promise<void>;
}
export declare function toURL(resource: URL | Multiaddr[], headers: Headers): URL;
/**
 * Normalizes byte-like input to a `Uint8Array`
 */
export declare function toUint8Array(obj: DataView | ArrayBuffer | Uint8Array): Uint8Array;
export declare function streamToRequest(info: HeaderInfo, stream: Stream): globalThis.Request;
export declare function responseToStream(res: Response, stream: Stream): Promise<void>;
export declare const NOT_FOUND_RESPONSE: Uint8Array<ArrayBufferLike>;
export declare const BAD_REQUEST: Uint8Array<ArrayBufferLike>;
export declare const INTERNAL_SERVER_ERROR: Uint8Array<ArrayBufferLike>;
export declare const NOT_IMPLEMENTED_ERROR: Uint8Array<ArrayBufferLike>;
export declare function writeHeaders(headers: Headers): string[];
/**
 * Attempts to convert the passed `resource` into a HTTP(s) URL or an array of
 * multiaddrs.
 *
 * The returned URL should be handled by the global fetch, the multiaddr(s)
 * should be handled by libp2p.
 */
export declare function toResource(resource: string | URL | PeerId | Multiaddr | Multiaddr[], path?: string): URL | Multiaddr[];
export declare function getHeaders(init?: RequestInit): Headers;
export declare function getHeader(header: string, headers?: HeadersInit): string | undefined;
export declare function getHost(addresses: URL | Multiaddr[], headers: Headers): string;
export declare function stripHTTPPath(addresses: Multiaddr[]): {
    httpPath: string;
    addresses: Multiaddr[];
};
export declare function normalizeMethod(method?: string | string[], defaultMethod?: string[]): string[];
/**
 * Returns a fully qualified URL representing the resource that is being
 * requested
 */
export declare function normalizeUrl(req: {
    url?: string;
    headers?: Headers | {
        host?: string;
    };
}): URL;
export declare function isWebSocketUpgrade(method: string, headers: Headers): boolean;
export declare function getServerUpgradeHeaders(headers: Headers | Record<string, string | string[] | undefined>): Promise<Headers>;
/**
 * Reads HTTP headers from an incoming stream
 */
export declare function readHeaders(stream: Stream, options?: AbortOptions): Promise<HeaderInfo>;
/**
 * Parsed from the incoming HTTP message
 */
export interface HeaderInfo {
    versionMajor: number;
    versionMinor: number;
    headers: Headers;
    method: string;
    url: string;
    statusCode: number;
    statusMessage: string;
    upgrade: boolean;
    shouldKeepAlive: boolean;
    raw: Uint8ArrayList;
}
export * from './request.js';
export * from './response.js';
export * from './constants.js';
export * from './stream-to-socket.js';
//# sourceMappingURL=index.d.ts.map