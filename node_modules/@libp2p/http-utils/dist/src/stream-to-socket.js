import { Duplex } from 'node:stream';
const MAX_TIMEOUT = 2_147_483_647;
export class Libp2pSocket extends Duplex {
    autoSelectFamilyAttemptedAddresses = [];
    connecting = false;
    pending = false;
    remoteAddress;
    bytesRead;
    bytesWritten;
    timeout = MAX_TIMEOUT;
    allowHalfOpen;
    remoteFamily;
    remotePort;
    #initStream;
    #stream;
    #log;
    constructor(...args) {
        super();
        this.bytesRead = 0;
        this.bytesWritten = 0;
        this.allowHalfOpen = true;
        this.remoteAddress = '';
        if (args.length === 2) {
            this.gotStream({ stream: args[0], connection: args[1] });
            this.#initStream = Promise.resolve(args[0]);
        }
        else {
            this.#initStream = args[0].then(this.gotStream.bind(this), (err) => {
                this.emit('error', err);
                throw err;
            });
        }
    }
    gotStream({ stream, connection }) {
        this.#log = stream.log.newScope('libp2p-socket');
        this.remoteAddress = connection.remoteAddr.toString();
        stream.addEventListener('message', (evt) => {
            this.push(evt.data.subarray());
        });
        stream.addEventListener('close', (evt) => {
            if (evt.error != null) {
                this.destroy(evt.error);
            }
            else {
                this.push(null);
            }
        });
        stream.pause();
        this.emit('connect');
        return stream;
    }
    getStream(cb) {
        if (this.#stream != null) {
            cb(this.#stream);
            return;
        }
        this.#initStream.then(stream => {
            this.#stream = stream;
            cb(stream);
        }, (err) => {
            this.emit('error', err);
        });
    }
    destroy(error) {
        return super.destroy(error);
    }
    _write(chunk, encoding, cb) {
        this.#log?.('write %d bytes', chunk.byteLength);
        this.bytesWritten += chunk.byteLength;
        this.getStream(stream => {
            if (!stream.send(chunk)) {
                stream.onDrain()
                    .then(() => {
                    cb();
                }, (err) => {
                    cb(err);
                });
            }
            else {
                cb();
            }
        });
    }
    _read(size) {
        this.#log?.('asked to read %d bytes', size);
        this.getStream(stream => {
            stream.resume();
        });
    }
    _destroy(err, cb) {
        this.#log?.('destroy with %d bytes buffered - %e', this.bufferSize, err);
        this.getStream(stream => {
            if (err != null) {
                stream.abort(err);
                cb();
            }
            else {
                stream.close()
                    .then(() => {
                    cb();
                })
                    .catch(err => {
                    stream.abort(err);
                    cb(err);
                });
            }
        });
    }
    _final(cb) {
        this.#log?.('final');
        this.getStream(stream => {
            stream.close()
                .then(() => {
                cb();
            })
                .catch(err => {
                stream.abort(err);
                cb(err);
            });
        });
    }
    get readyState() {
        if (this.#stream?.status === 'closed') {
            return 'closed';
        }
        if (this.#stream?.writeStatus === 'closed' || this.#stream?.writeStatus === 'closing') {
            return 'readOnly';
        }
        if (this.#stream?.readStatus === 'closed' || this.#stream?.readStatus === 'closing') {
            return 'writeOnly';
        }
        return 'open';
    }
    get bufferSize() {
        return this.writableLength;
    }
    destroySoon() {
        this.#log?.('destroySoon with %d bytes buffered', this.bufferSize);
        this.destroy();
    }
    connect(...args) {
        this.#log?.('connect %o', args);
        return this;
    }
    setEncoding(encoding) {
        this.#log?.('setEncoding %s', encoding);
        return this;
    }
    resetAndDestroy() {
        this.#log?.('resetAndDestroy');
        this.getStream(stream => {
            stream.abort(new Error('Libp2pSocket.resetAndDestroy'));
        });
        return this;
    }
    setTimeout(timeout, callback) {
        this.#log?.('setTimeout %d', timeout);
        if (callback != null) {
            this.addListener('timeout', callback);
        }
        this.timeout = timeout === 0 ? MAX_TIMEOUT : timeout;
        return this;
    }
    setNoDelay(noDelay) {
        this.#log?.('setNoDelay %b', noDelay);
        return this;
    }
    setKeepAlive(enable, initialDelay) {
        this.#log?.('setKeepAlive %b %d', enable, initialDelay);
        return this;
    }
    address() {
        this.#log?.('address');
        return {};
    }
    unref() {
        this.#log?.('unref');
        return this;
    }
    ref() {
        this.#log?.('ref');
        return this;
    }
    write(chunk, encoding, cb) {
        return super.write(chunk, encoding, cb);
    }
}
export function streamToSocket(stream, connection) {
    return new Libp2pSocket(stream, connection);
}
//# sourceMappingURL=stream-to-socket.js.map