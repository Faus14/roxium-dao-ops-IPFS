import { TypedEventEmitter } from '@libp2p/interface';
import { BitswapMessage } from './pb/message.js';
import type { WantOptions } from './bitswap.js';
import type { MultihashHasherLoader } from './index.js';
import type { Block } from './pb/message.js';
import type { QueuedBitswapMessage } from './utils/bitswap-message.js';
import type { Provider, Routing } from '@helia/interface/routing';
import type { Libp2p, AbortOptions, Connection, PeerId, ComponentLogger, Metrics, Stream } from '@libp2p/interface';
import type { Multiaddr } from '@multiformats/multiaddr';
import type { CID } from 'multiformats/cid';
import type { ProgressEvent, ProgressOptions } from 'progress-events';
export interface BitswapProvider {
    /**
     * The type of provider
     */
    type: 'bitswap';
    /**
     * the CID the provider can supply the block for
     */
    cid: CID;
    /**
     * The provider info
     */
    provider: Provider;
    /**
     * Which routing subsystem found the provider
     */
    routing: string;
}
export type BitswapNetworkProgressEvents = ProgressEvent<'bitswap:dial', PeerId | Multiaddr | Multiaddr[]>;
export type BitswapNetworkWantProgressEvents = ProgressEvent<'bitswap:send-wantlist', PeerId> | ProgressEvent<'bitswap:send-wantlist:error', {
    peer: PeerId;
    error: Error;
}> | ProgressEvent<'bitswap:find-providers', CID> | ProgressEvent<'bitswap:found-provider', BitswapProvider> | BitswapNetworkProgressEvents;
export type BitswapNetworkNotifyProgressEvents = BitswapNetworkProgressEvents | ProgressEvent<'bitswap:send-block', PeerId>;
export interface NetworkInit {
    hashLoader?: MultihashHasherLoader;
    maxInboundStreams?: number;
    maxOutboundStreams?: number;
    messageReceiveTimeout?: number;
    messageSendConcurrency?: number;
    protocols?: string[];
    runOnLimitedConnections?: boolean;
    maxOutgoingMessageSize?: number;
    maxIncomingMessageSize?: number;
}
export interface NetworkComponents {
    routing: Routing;
    logger: ComponentLogger;
    libp2p: Libp2p;
    metrics?: Metrics;
}
export interface BitswapMessageEventDetail {
    peer: PeerId;
    message: BitswapMessage;
}
export interface NetworkEvents {
    'bitswap:message': CustomEvent<{
        peer: PeerId;
        message: BitswapMessage;
    }>;
    'peer:connected': CustomEvent<PeerId>;
    'peer:disconnected': CustomEvent<PeerId>;
}
export declare class Network extends TypedEventEmitter<NetworkEvents> {
    private readonly log;
    private readonly libp2p;
    private readonly routing;
    private readonly protocols;
    private running;
    private readonly maxInboundStreams;
    private readonly maxOutboundStreams;
    private readonly messageReceiveTimeout;
    private registrarIds;
    private readonly metrics;
    private readonly sendQueue;
    private readonly runOnLimitedConnections;
    private readonly maxOutgoingMessageSize;
    private readonly maxIncomingMessageSize;
    constructor(components: NetworkComponents, init?: NetworkInit);
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Handles incoming bitswap messages
     */
    _onStream(stream: Stream, connection: Connection): void;
    /**
     * Find bitswap providers for a given `cid`.
     */
    findProviders(cid: CID, options?: AbortOptions & ProgressOptions<BitswapNetworkWantProgressEvents>): AsyncIterable<Provider>;
    /**
     * Find the providers of a given `cid` and connect to them.
     */
    findAndConnect(cid: CID, options?: WantOptions): Promise<void>;
    /**
     * Connect to the given peer
     * Send the given msg (instance of Message) to the given peer
     */
    sendMessage(peerId: PeerId, message: QueuedBitswapMessage, options?: AbortOptions & ProgressOptions<BitswapNetworkWantProgressEvents>): Promise<void>;
    /**
     * Connects to another peer
     */
    connectTo(peer: PeerId | Multiaddr | Multiaddr[], options?: AbortOptions & ProgressOptions<BitswapNetworkProgressEvents>): Promise<Connection>;
    _updateSentStats(blocks: Map<string, Block>): void;
}
//# sourceMappingURL=network.d.ts.map