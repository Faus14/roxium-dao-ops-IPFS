/**
 * @packageDocumentation
 *
 * This module contains utility code that is shared between various Helia
 * modules such as `helia`, `@helia/http`, etc.
 */
import { contentRoutingSymbol, peerRoutingSymbol, start, stop, TypedEventEmitter } from '@libp2p/interface';
import { defaultLogger } from '@libp2p/logger';
import { dns } from '@multiformats/dns';
import drain from 'it-drain';
import { CustomProgressEvent } from 'progress-events';
import { PinsImpl } from './pins.js';
import { Routing as RoutingClass } from './routing.js';
import { BlockStorage } from './storage.js';
import { assertDatastoreVersionIsCurrent } from './utils/datastore-version.js';
import { getCodec } from './utils/get-codec.js';
import { getHasher } from './utils/get-hasher.js';
import { NetworkedStorage } from './utils/networked-storage.js';
export { AbstractSession } from './abstract-session.js';
export { breadthFirstWalker, depthFirstWalker } from "./graph-walker.js";
export class Helia {
    libp2p;
    blockstore;
    datastore;
    events;
    pins;
    logger;
    routing;
    getCodec;
    getHasher;
    dns;
    metrics;
    log;
    constructor(init) {
        this.logger = init.logger ?? defaultLogger();
        this.log = this.logger.forComponent('helia');
        this.getHasher = getHasher(init.hashers, init.loadHasher);
        this.getCodec = getCodec(init.codecs, init.loadCodec);
        this.dns = init.dns ?? dns();
        this.metrics = init.metrics;
        this.libp2p = init.libp2p;
        this.events = new TypedEventEmitter();
        // @ts-expect-error routing is not set
        const components = {
            blockstore: init.blockstore,
            datastore: init.datastore,
            logger: this.logger,
            libp2p: this.libp2p,
            blockBrokers: [],
            getHasher: this.getHasher,
            getCodec: this.getCodec,
            dns: this.dns,
            metrics: this.metrics,
            ...(init.components ?? {})
        };
        this.routing = components.routing = new RoutingClass(components, {
            routers: (init.routers ?? []).flatMap((router) => {
                if (typeof router === 'function') {
                    router = router(components);
                }
                // if the router itself is a router
                const routers = [
                    router
                ];
                // if the router provides a libp2p-style ContentRouter
                const contentRouting = asContentRouting(router);
                if (contentRouting != null) {
                    routers.push(contentRouting);
                }
                // if the router provides a libp2p-style PeerRouter
                const peerRouting = asPeerRouting(router);
                if (peerRouting != null) {
                    routers.push(peerRouting);
                }
                return routers;
            }),
            providerLookupConcurrency: init.providerLookupConcurrency
        });
        const networkedStorage = new NetworkedStorage(components, init);
        this.pins = new PinsImpl(init.datastore, networkedStorage, this.getCodec);
        this.blockstore = new BlockStorage(networkedStorage, this.pins, {
            holdGcLock: init.holdGcLock ?? true
        });
        this.datastore = init.datastore;
        components.blockBrokers = init.blockBrokers.map((fn) => {
            return fn(components);
        });
    }
    async start() {
        await assertDatastoreVersionIsCurrent(this.datastore);
        await start(this.blockstore, this.datastore, this.routing, this.libp2p);
        this.events.dispatchEvent(new CustomEvent('start', { detail: this }));
    }
    async stop() {
        await stop(this.blockstore, this.datastore, this.routing, this.libp2p);
        this.events.dispatchEvent(new CustomEvent('stop', { detail: this }));
    }
    async gc(options = {}) {
        const releaseLock = await this.blockstore.lock.writeLock();
        try {
            const helia = this;
            const blockstore = this.blockstore.unwrap();
            this.log('gc start');
            await drain(blockstore.deleteMany((async function* () {
                for await (const { cid } of blockstore.getAll()) {
                    try {
                        if (await helia.pins.isPinned(cid, options)) {
                            continue;
                        }
                        yield cid;
                        options.onProgress?.(new CustomProgressEvent('helia:gc:deleted', cid));
                    }
                    catch (err) {
                        helia.log.error('error during gc - %e', err);
                        options.onProgress?.(new CustomProgressEvent('helia:gc:error', err));
                    }
                }
            }())));
        }
        finally {
            releaseLock();
        }
        this.log('gc finished');
    }
}
function asContentRouting(obj) {
    return obj?.[contentRoutingSymbol];
}
function asPeerRouting(obj) {
    return obj?.[peerRoutingSymbol];
}
//# sourceMappingURL=index.js.map