import { Queue } from '@libp2p/utils';
import filter from 'it-filter';
import toBuffer from 'it-to-buffer';
import { createUnsafe } from 'multiformats/block';
export function depthFirstWalker(components, init = {}) {
    return new DepthFirstGraphWalker(components, init);
}
export function breadthFirstWalker(components, init = {}) {
    return new BreadthFirstGraphWalker(components, init);
}
class AbstractGraphWalker {
    components;
    constructor(components, init) {
        this.components = components;
    }
    async *walk(cid, options) {
        const queue = this.getQueue();
        const gen = filter(queue.toGenerator(options), (node) => node != null);
        let finished = false;
        const job = async (opts) => {
            const cid = opts.cid;
            const bytes = await toBuffer(this.components.blockstore.get(cid, opts));
            const block = createUnsafe({
                cid,
                bytes,
                codec: await this.components.getCodec(cid.code)
            });
            for (const [, linkedCid] of block.links()) {
                if (options?.includeChild?.(linkedCid, block) === false) {
                    continue;
                }
                queue.add(job, {
                    ...opts,
                    cid: linkedCid,
                    depth: opts.depth + 1,
                    path: [...opts.path, linkedCid]
                })
                    // eslint-disable-next-line no-loop-func
                    .catch(err => {
                    // only throw if the generator is still yielding results, otherwise
                    // it can cause unhandled promise rejections
                    if (!finished) {
                        gen.throw(err);
                    }
                });
            }
            return {
                block,
                depth: opts.depth,
                path: opts.path
            };
        };
        queue.add(job, {
            ...options,
            cid,
            depth: 0,
            path: [cid]
        })
            .catch(err => {
            // only throw if the generator is still yielding results, otherwise it
            // can cause unhandled promise rejections
            if (!finished) {
                gen.throw(err);
            }
        });
        try {
            yield* gen;
        }
        finally {
            finished = true;
            // abort any in-progress operations
            queue.abort();
        }
    }
}
class DepthFirstGraphWalker extends AbstractGraphWalker {
    getQueue() {
        return new Queue({
            concurrency: 1,
            sort: (a, b) => {
                if (a.options.depth === b.options.depth) {
                    return 0;
                }
                if (a.options.depth < b.options.depth) {
                    return 1;
                }
                return -1;
            }
        });
    }
}
class BreadthFirstGraphWalker extends AbstractGraphWalker {
    getQueue() {
        return new Queue({
            concurrency: 1,
            sort: (a, b) => {
                if (a.options.depth === b.options.depth) {
                    return 0;
                }
                if (a.options.depth < b.options.depth) {
                    return -1;
                }
                return 1;
            }
        });
    }
}
//# sourceMappingURL=graph-walker.js.map