{
  "version": 3,
  "sources": ["../src/index.ts", "../../../node_modules/get-iterator/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Turns an (async)iterable into a W3C ReadbleStream.\n *\n * @example\n *\n * ```javascript\n * import toBrowserReadableStream from 'it-to-browser-readablestream'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values = [Buffer.from([0, 1]), Buffer.from([2, 3])]\n *\n * const stream = await toBrowserReadableStream(values)\n *\n * for await (const buf of stream) {\n *   console.info(buf) // Buffer[0, 1]\n * }\n * ```\n */\n\nimport { getIterator } from 'get-iterator'\n\ninterface SourceExt {\n  _cancelled: boolean\n}\n\ntype Source<T> = SourceExt & UnderlyingSource<T>\n\n/**\n * Converts an (async) iterator into a WHATWG ReadableStream\n */\nexport default function itToBrowserReadableStream <T extends ArrayBufferView> (source: AsyncIterable<T> | Iterable<T>, queuingStrategy: QueuingStrategy<T> = {}): ReadableStream<T> {\n  const iter = getIterator<T>(source)\n\n  const s: Source<ArrayBufferView> = {\n    _cancelled: false,\n\n    async start () {\n      this._cancelled = false\n    },\n    async pull (controller) {\n      try {\n        const { value, done } = await iter.next()\n\n        if (this._cancelled) {\n          return\n        }\n\n        if (done === true) {\n          controller.close()\n          return\n        }\n\n        controller.enqueue(value)\n      } catch (err) {\n        controller.error(err)\n      }\n    },\n    cancel () {\n      this._cancelled = true\n    }\n  }\n\n  return new globalThis.ReadableStream(s, queuingStrategy)\n}\n", "\n// If the passed object is an (async) iterable, then get the iterator\n// If it's probably an iterator already (i.e. has next function) return it\n// else throw\nexport function getIterator <T> (obj: AsyncIterable<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: AsyncIterator<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: Iterable<T>): Iterator<T>\nexport function getIterator <T> (obj: Iterator<T>): Iterator<T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T> {\n  if (obj != null) {\n    if (typeof obj[Symbol.iterator] === 'function') {\n      return obj[Symbol.iterator]()\n    }\n    if (typeof obj[Symbol.asyncIterator] === 'function') {\n      return obj[Symbol.asyncIterator]()\n    }\n    if (typeof obj.next === 'function') {\n      return obj // probably an iterator\n    }\n  }\n  throw new Error('argument is not an iterator or iterable')\n}\n"],
  "mappings": ";6cAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,ICSM,SAAUC,EAAiBC,EAAQ,CACvC,GAAIA,GAAO,KAAM,CACf,GAAI,OAAOA,EAAI,OAAO,QAAQ,GAAM,WAClC,OAAOA,EAAI,OAAO,QAAQ,EAAC,EAE7B,GAAI,OAAOA,EAAI,OAAO,aAAa,GAAM,WACvC,OAAOA,EAAI,OAAO,aAAa,EAAC,EAElC,GAAI,OAAOA,EAAI,MAAS,WACtB,OAAOA,EAGX,MAAM,IAAI,MAAM,yCAAyC,CAC3D,CDUc,SAAPC,EAAwEC,EAAwCC,EAAsC,CAAA,EAAE,CAC7J,IAAMC,EAAOC,EAAeH,CAAM,EAE5BI,EAA6B,CACjC,WAAY,GAEZ,MAAM,OAAK,CACT,KAAK,WAAa,EACpB,EACA,MAAM,KAAMC,EAAU,CACpB,GAAI,CACF,GAAM,CAAE,MAAAC,EAAO,KAAAC,CAAI,EAAK,MAAML,EAAK,KAAI,EAEvC,GAAI,KAAK,WACP,OAGF,GAAIK,IAAS,GAAM,CACjBF,EAAW,MAAK,EAChB,MACF,CAEAA,EAAW,QAAQC,CAAK,CAC1B,OAASE,EAAK,CACZH,EAAW,MAAMG,CAAG,CACtB,CACF,EACA,QAAM,CACJ,KAAK,WAAa,EACpB,GAGF,OAAO,IAAI,WAAW,eAAeJ,EAAGH,CAAe,CACzD",
  "names": ["index_exports", "__export", "itToBrowserReadableStream", "getIterator", "obj", "itToBrowserReadableStream", "source", "queuingStrategy", "iter", "getIterator", "s", "controller", "value", "done", "err"]
}
